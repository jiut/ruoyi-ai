# 解绑用户身份接口权限修复

## 🔍 问题描述

用户在调用 `/designer/user/unbind/{entityType}` 接口解绑身份时，返回403权限错误：

```json
{
    "code": 403,
    "msg": "没有访问权限，请联系管理员授权",
    "data": null
}
```

## 🎯 问题原因

原始接口使用了 `@SaCheckPermission("designer:user:unbind")` 权限检查，需要特定的系统权限才能访问。但对于用户自行解绑身份的操作，这应该是一个基本权限，只要是已登录用户就应该能够执行。

## ✅ 解决方案

### 权限注解修改

**修改前**:
```java
@SaCheckPermission("designer:user:unbind")
@Log(title = "解绑用户身份", businessType = BusinessType.UPDATE)
@PutMapping("/unbind/{entityType}")
public R<Void> unbindUserIdentity(@PathVariable String entityType) {
```

**修改后**:
```java
@SaCheckLogin
@Log(title = "解绑用户身份", businessType = BusinessType.UPDATE)
@PutMapping("/unbind/{entityType}")
public R<Void> unbindUserIdentity(@PathVariable String entityType) {
```

### 权限级别对比

| 权限注解 | 权限级别 | 适用场景 | 说明 |
|---------|---------|----------|------|
| `@SaCheckPermission("designer:user:unbind")` | 系统管理员权限 | 管理员操作 | 需要特定权限配置 |
| `@SaCheckLogin` | 登录用户权限 | 用户自助操作 | 只需要登录即可 |

## 🔒 安全性保障

虽然降低了权限要求，但接口仍然是安全的：

### 1. 用户身份验证
- `@SaCheckLogin` 确保只有已登录用户才能访问
- `LoginHelper.getUserId()` 获取当前登录用户ID

### 2. 权限范围限制
- 用户只能解绑自己的身份（通过userId限制）
- 无法解绑其他用户的身份
- 无法进行越权操作

### 3. 业务逻辑验证
```java
Long userId = LoginHelper.getUserId(); // 获取当前用户ID
userBindingService.unbindUserFromEntity(userId, type); // 只解绑当前用户
```

## 🚀 测试验证

### 1. Apifox测试配置

**接口**: `PUT {{base_url}}/designer/user/unbind/{entityType}`

**Headers**:
```
Authorization: Bearer {{access_token}}
```

**路径参数**:
- `entityType`: 实体类型
  - `designer` - 解绑设计师身份
  - `enterprise` - 解绑企业身份
  - `school` - 解绑院校身份

### 2. 测试用例

#### 测试用例1：解绑设计师身份
```
PUT /designer/user/unbind/designer
```

**预期结果**:
```json
{
    "code": 200,
    "msg": "操作成功",
    "data": null
}
```

#### 测试用例2：解绑企业身份
```
PUT /designer/user/unbind/enterprise
```

#### 测试用例3：解绑院校身份
```
PUT /designer/user/unbind/school
```

#### 测试用例4：无效实体类型
```
PUT /designer/user/unbind/invalid
```

**预期结果**:
```json
{
    "code": 500,
    "msg": "无效的实体类型",
    "data": null
}
```

### 3. 验证方法

#### 数据库验证
解绑成功后，检查数据库：
```sql
SELECT binding_status 
FROM des_user_binding 
WHERE user_id = {当前用户ID} AND entity_type = '{entityType}';
```

**预期结果**: `binding_status` 应该变为 `'0'`（解绑状态）

#### 接口验证
调用绑定信息查询接口确认：
```
GET /designer/user/bindings
```

解绑的身份应该不再出现在返回列表中。

## 📋 管理员接口保持不变

管理员绑定接口仍然保持原有权限：

```java
@SaCheckPermission("designer:user:bind")
@PostMapping("/bind")
public R<Void> bindUserToEntity(@RequestParam Long userId,
                                @RequestParam String entityType,
                                @RequestParam Long entityId)
```

这确保了：
- 用户可以自行解绑身份（自助服务）
- 只有管理员可以为其他用户绑定身份（权限控制）

## 🎯 权限设计原则

### 自助操作权限
- **解绑身份**: `@SaCheckLogin` - 用户可以自行解绑
- **查询自己的绑定信息**: 无特殊权限要求
- **注册新身份**: 无特殊权限要求

### 管理员操作权限
- **为其他用户绑定身份**: `@SaCheckPermission("designer:user:bind")`
- **查询所有用户绑定**: 需要管理员权限
- **强制解绑其他用户**: 需要管理员权限

## ✅ 修复完成

现在用户可以：
1. ✅ 自行注册设计师/企业/院校身份
2. ✅ 查询自己的绑定信息
3. ✅ 自行解绑任何已绑定的身份
4. ✅ 无需联系管理员进行解绑操作

这种权限设计既保证了用户的自主性，又维护了系统的安全性。 